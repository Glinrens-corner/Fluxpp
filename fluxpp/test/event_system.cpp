#include <doctest/doctest.h>
#include "event_system.hpp"
#include "widget.hpp"

namespace {
  using string_id_t = fluxpp::id::Id<fluxpp::event_system::StringIdTag>;
  using fluxpp::event_system::GlobalStringMapper;
  string_id_t sadfa_id = GlobalStringMapper::get_instance()
    .map_string("sadfa");
  string_id_t sadfa_id2 = GlobalStringMapper::get_instance()
    .map_string("sadfa");
  string_id_t orf_id = GlobalStringMapper::get_instance()
    .map_string("orf 22");
  string_id_t state_id = GlobalStringMapper::get_instance()
    .map_string("state");
  string_id_t app_id = GlobalStringMapper::get_instance()
    .map_string("app");
  string_id_t backend_id = GlobalStringMapper::get_instance()
    .map_string("backend");
}//


TEST_CASE("global_mapper"){
   
  auto local_mapper = GlobalStringMapper::get_instance()
    .create_local_mapper();
  SUBCASE("is_sealed"){
    // after a local_mapper is created the global mapper is sealed
    CHECK(GlobalStringMapper::get_instance().is_sealed());
    SUBCASE("create_second_local_mapper"){
      REQUIRE(GlobalStringMapper::get_instance().is_sealed());
      // even sealed a global string mapper can create multiple
      auto local_mapper = GlobalStringMapper::get_instance()
        .create_local_mapper();
      CHECK(true);
    };
    SUBCASE("sealed string_mapping"){
      REQUIRE(GlobalStringMapper::get_instance().is_sealed());
      // a sealed GlobalStringMapper cannot map new strings
      CHECK_THROWS(GlobalStringMapper::get_instance()
                   .map_string("orf 22"));
    };
  };
  // the GlobalStringMapper can create an ID for a string
  SUBCASE("different strings"){
    // different strings are mapped to different ids.
    CHECK(sadfa_id != orf_id);
  };
  
  SUBCASE("repeated string mapping"){
    // mapping the same string repeatedly results in the same id.
    CHECK(sadfa_id == sadfa_id2);
  };
};

TEST_CASE("local_mapper"){
  using namespace fluxpp::event_system;

  LocalStringMapper local_mapper1 = GlobalStringMapper::get_instance()
    .create_local_mapper();
  LocalStringMapper local_mapper2 = GlobalStringMapper::get_instance()
    .create_local_mapper();
  SUBCASE("global_lookup"){
    // you can lookup ids generated by the global_mapper via the local mapper

    LocalStringMapperInterface ifc =local_mapper1
      .get_interface(); 
    CHECK( sadfa_id == ifc
           .map_string("sadfa") );
    CHECK( sadfa_id == ifc
           .id_by_string("sadfa")
           .value() );
    CHECK( "sadfa" == ifc
           .string_by_id(sadfa_id)
           .value()
           .get());
  };
  SUBCASE("create new entry"){    
    LocalStringMapperInterface ifc =local_mapper1
      .get_interface(); 
    LocalStringMapperInterface::id_t
      somethign_id = ifc
      .map_string("somethign");
    CHECK(somethign_id != sadfa_id);
    CHECK(somethign_id != orf_id);
    CHECK(somethign_id  ==ifc
          .map_string("somethign"));
    CHECK(somethign_id  ==ifc
          .id_by_string("somethign")
          .value());
  };
  SUBCASE("lookup non existent entry"){
    ConstLocalStringMapperInterface ifc =static_cast<const LocalStringMapper*>(&local_mapper1)
      ->get_interface();
    CHECK_FALSE(ifc.id_by_string("somethign").has_value());
  };
};


TEST_CASE("Portal"){
  using namespace fluxpp::event_system;
  auto portal = Portal{};
  
  
};


TEST_CASE("EventSystem"){
  using namespace fluxpp::event_system;
  auto local_mapper = GlobalStringMapper::get_instance()
    .create_local_mapper();
  std::vector<fluxpp::id::Id<StringIdTag>> ids{app_id, backend_id, state_id };
  EventSystem event_system = EventSystem::create(std::move(ids), &local_mapper);
  auto&  app_portal =  event_system.get_portal({app_id} );
  bool was_called = false;
  app_portal.set_dispatcher([&was_called](fluxpp::event_system::AbstractEvent * event){
      CHECK( static_cast<bool>(dynamic_cast<fluxpp::event_system::DataEvent<int>*>(event) ));
      was_called = true;
    });
  Port port = event_system.get_port();
  port.dispatch_event(
      fluxpp::event_system::Path{{{app_id}, {orf_id}}} ,
      DataEvent<int>{fluxpp::event_system::Path{{{app_id}, {orf_id}}},1});
  CHECK(was_called);
};
